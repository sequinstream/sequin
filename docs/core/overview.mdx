---
title: 'Overview'
description: 'Sequin has three core concepts: database change data capture (CDC), streams, and consumers.'
---

1. Sequin detects every change in your [**database**](#database-change-data-capture-cdc) (CDC) using the Write Ahead Log (WAL).
2. Those changes are then captured into a durable, persistent queue of messages called a [**stream**](#streams).
3. You then use [**consumers**](#consumers) to filter, transform, and send those messages to your application or another service.

## Database change data capture (CDC)

Sequin uses the [Write Ahead Log (WAL)](https://www.postgresql.org/docs/current/logicaldecoding-explanation.html) to detect changes in your database. The WAL is a log of all the changes that have been made to your database.

When connecting Sequin to your database, you'll configure the WAL by creating a [replication slot](https://www.postgresql.org/docs/9.4/catalog-pg-replication-slots.html) and a [publication](https://www.postgresql.org/docs/current/logical-replication-publication.html). The publication determines which tables are captured by the replication slot.

This architecture allows Sequin to provide transactional guarantees and never miss a change, even across long periods of downtime.

## Streams

Each change in your database is captured into a durable, persistent sequence of messages called a stream. By storing messages in a stream, Sequin can provide exactly-once processing guarantees.

You'll configure a stream in the process of creating a new consumer (there is a one-to-one relationship between streams and consumers).

There are three types of streams:

### Change stream

Change streams are useful for applications that need to process every change in your database as a unique event.

* **Change types**: A change stream contains every insert, update, and delete and captures both the old and new values of the changed record.
* **Timeframe**: A change stream only processes new changes. There are no backwards-looking changes.
* **Retention**: Once a message in a change stream is acknowledged by a consumer, it is removed from the stream. There are no replays or rewinds.

### Change stream with retention (coming soon)

As the name suggests, change streams with retention are the same as change streams, but they have a configurable retention period.

This is useful for applications that need to process changes and retain them for a period of time (i.e. audit logs).

* **Change types**: A change stream contains every insert, update, and delete and captures both the old and new values of the changed record.
* **Timeframe**: A change stream only processes new changes from a point in time forward.
* **Retention**: Messages are not removed from the stream when acknowledged by a consumer. This means that a change stream can be replayed or rewound.

### Sync stream

Sync streams are useful for applications that need to know the current state of a record, or for applications that need to replay changes from a point in time.

* **Change types**: A sync stream contains one message that represents the current state of each record in your database. A sync stream only captures inserts and updates. Hard deletes are not captured.
* **Timeframe**: A sync stream can backfill the full history of your database, or capture changes from a point in time forward.
* **Retention**: Messages in a sync stream are not removed when acknowledged by a consumer. This means that a sync stream can be replayed or rewound.

## Consumers

Consumers allow you to filter, transform, and send messages from a stream to your application or another service. A consumer will process messages for one stream (there is a one-to-one relationship between consumers and streams).

### Filtering

 You can filter which messages are processed in two ways:
 1. Operation type: You can choose to only process `insert`, `update`, or `delete` messages.
 2. Condition: You can choose to only process messages that match a SQL `WHERE` clause.

### Transforming (coming soon)

You can transform messages in a stream using LUA. This is useful for transforming the data into a format that your application needs.

### HTTP interface

Consumers can push messsages to your application via webhooks (a.k.a. **push consumers**), or you can pull messages from the consumer using Sequin's HTTP API (a.k.a. **pull consumers**).

**Push consumers**

When using push consumers (i.e. webhooks), Sequin will send POST requests to the endpoint you provide.

**Pull consumers**

You can pull messages from the consumer using Sequin's HTTP API or SDKs. This gives your application more control over messages are processed.

### Acknowledgement

To provide exactly-once processing, Sequin requires that every message is acknowledged by a consumer.

* **Push consumers:** A message is acknowledge by push consumers when Sequin receives a `200 OK` response to a webhook. If any other response is received, the message is not acknowledged (i.e. `nack`) and will be retried. Similarly, if the message is not acknowledged within the consumer's retry limit, the message will be marked as `nack` and retried.
* **Pull consumers:** A message is explicitly acknowledged by pull consumers by sending a message's `ack_id` in a subsequent `POST /consumers/:consumer_id/ack` request. A message can be explicitly not acknowledged (i.e. `nack`) by sending a messages `ack_id` in a subsequent `POST /consumers/:consumer_id/nack` request. Similarly, if the message is not acknowledged within the pull consumer's visability timeout, the message will be marked as `nack` and retried.

## Guarantees

### Transactional enqueue

Sequin guarantees that every insert, update, and delete is captured, respecting the order of operations in any transaction.

### Strict ordering

Sequin guarantees that messages with the same primary key are processed in order for a given stream and consumer.

This is useful for applications that need to process changes to a single record in order. For example, if you're processing changes to a user's profile, you want to make sure that the changes are applied in order.

To achieve this, Sequin will not deliver messages to a consumer until the previous messages for that primary key has been acknowledged.

### Exactly-one processing

Sequin guarantees that messages are delivered at least once and must be acknowledged by a consumer. This means that no messages are lost in transit.